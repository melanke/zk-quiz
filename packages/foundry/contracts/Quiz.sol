// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title Zokrates verifier interface
 * @dev Interface matching the actual AnswerVerifier.sol contract generated by ZoKrates.
 *      The circuit expects: [address, expectedAnswerHash, <additional_public_input>]
 */
interface IZokratesVerifier {
    struct G1Point {
        uint256 X;
        uint256 Y;
    }

    struct G2Point {
        uint256[2] X;
        uint256[2] Y;
    }

    struct Proof {
        G1Point a;
        G2Point b;
        G1Point c;
    }

    function verifyTx(Proof memory proof, uint256[3] memory input) external view returns (bool);
}

/**
 * @title Quiz
 * @notice Minimal, gas-efficient quest graph with:
 *         - answerHash (uint256) as the unique quest identifier
 *         - optional single dependency per quest (forming a DAG of chains/branches)
 *         - root quest listing + listing quests by dependency (with pagination)
 *         - zk check-in: verifies a ZoKrates proof whose public inputs are [address, answerHash]
 *         - check-in marks the current quest and walks up the chain to mark all ancestors
 *         - check-in stores the block number of completion instead of a boolean
 */
contract Quiz {
    IZokratesVerifier public verifier;

    // ------------------------------
    // Storage
    // ------------------------------

    // Quest question text, indexed by answerHash
    mapping(uint256 => string) public questQuestions;

    // Each quest's single dependency (0 if this is a root quest)
    mapping(uint256 => uint256) public questDependency;

    // Root quests (quests with dependency == 0)
    uint256[] public rootQuests;

    // For navigation downwards: dependencyHash => list of quests that depend on it
    mapping(uint256 => uint256[]) public questsByDependency;

    // Check-ins: answerHash => user => blockNumber of completion (0 = not completed)
    mapping(uint256 => mapping(address => uint256)) public checkIn;

    // ------------------------------
    // Events
    // ------------------------------

    event QuestCreated(uint256 indexed answerHash, address indexed creator, string question, uint256 dependency);
    event CheckedIn(address indexed user, uint256 indexed answerHash, string question, uint256 blockNumber);

    // ------------------------------
    // Constructor
    // ------------------------------

    constructor(address verifierAddress) {
        require(verifierAddress != address(0), "Invalid verifier");
        verifier = IZokratesVerifier(verifierAddress);
    }

    // ------------------------------
    // Quest creation
    // ------------------------------

    /**
     * @notice Create a new quest.
     * @param question   The question (string)
     * @param answerHash The unique identifier of the quest (Poseidon hash of the answer)
     * @param dependency The answerHash of the required previous quest, or 0 for a root quest
     */
    function createQuest(string memory question, uint256 answerHash, uint256 dependency) external {
        require(bytes(questQuestions[answerHash]).length == 0, "Quest already exists");
        if (dependency != 0) {
            // Optional sanity check to ensure dependency exists
            require(bytes(questQuestions[dependency]).length != 0, "Dependency does not exist");
        }

        questQuestions[answerHash] = question;
        questDependency[answerHash] = dependency;

        if (dependency == 0) {
            rootQuests.push(answerHash);
        } else {
            questsByDependency[dependency].push(answerHash);
        }

        emit QuestCreated(answerHash, msg.sender, question, dependency);
    }

    // ------------------------------
    // Listing (pagination)
    // ------------------------------

    /**
     * @notice List root quests (quests with no dependency) with pagination.
     * @param start Index to start from (0-based)
     * @param limit Maximum number of items to return
     */
    function listRootQuests(uint256 start, uint256 limit) external view returns (uint256[] memory) {
        uint256 len = rootQuests.length;
        if (start >= len) {
            return new uint256[](0);
        }
        uint256 end = start + limit;
        if (end > len) end = len;

        uint256[] memory result = new uint256[](end - start);
        for (uint256 i = start; i < end; i++) {
            result[i - start] = rootQuests[i];
        }
        return result;
    }

    /**
     * @notice List quests that depend on a given quest (by answerHash), with pagination.
     * @param dependencyHash The parent quest's answerHash
     * @param start          Index to start from (0-based)
     * @param limit          Maximum number of items to return
     */
    function listQuestsByDependency(uint256 dependencyHash, uint256 start, uint256 limit)
        external
        view
        returns (uint256[] memory)
    {
        uint256[] storage deps = questsByDependency[dependencyHash];
        uint256 len = deps.length;
        if (start >= len) {
            return new uint256[](0);
        }
        uint256 end = start + limit;
        if (end > len) end = len;

        uint256[] memory result = new uint256[](end - start);
        for (uint256 i = start; i < end; i++) {
            result[i - start] = deps[i];
        }
        return result;
    }

    // ------------------------------
    // Upward traversal (dependencies)
    // ------------------------------

    /**
     * @notice Return the chain of dependencies from a quest up to the root (excluding the starting quest).
     *         The first element is the direct dependency; the last element is the highest ancestor (root).
     * @param answerHash The quest to start from
     */
    function getDependencies(uint256 answerHash) external view returns (uint256[] memory) {
        // First pass: compute depth
        uint256 depth = 0;
        uint256 current = answerHash;
        while (current != 0 && questDependency[current] != 0) {
            current = questDependency[current];
            depth++;
        }

        // Second pass: build the path
        uint256[] memory path = new uint256[](depth);
        current = answerHash;
        for (uint256 i = 0; i < depth; i++) {
            current = questDependency[current];
            path[i] = current;
        }
        return path;
    }

    // ------------------------------
    // ZK check-in
    // ------------------------------

    /**
     * @notice Verify a zk proof and check-in the sender for the quest and all its ancestors.
     * @dev Expects publicInputs = [address, expectedAnswerHash, additionalInput].
     *      The ZoKrates circuit verifies that the user knows the answer that hashes to expectedAnswerHash.
     *
     *      Security notes:
     *        - The verifier proof binds the public inputs. We assert:
     *            publicInputs[0] == uint256(uint160(msg.sender))
     *            publicInputs[1] == answerHash (expectedAnswerHash from circuit)
     *        - Then we mark the quest and walk upward, marking each ancestor until the root or
     *          until we encounter one already marked (to avoid redundant writes).
     *
     * @param proof        ZoKrates proof struct matching AnswerVerifier format
     * @param publicInputs Public inputs array: [address, expectedAnswerHash, additionalInput]
     */
    function checkInQuest(IZokratesVerifier.Proof memory proof, uint256[3] memory publicInputs) external {
        uint256 userAddress = publicInputs[0];
        uint256 answerHash = publicInputs[1];

        // 1) Verify proof against the verifier contract
        require(verifier.verifyTx(proof, publicInputs), "Invalid proof");

        // 2) Enforce that msg.sender is the same as the first public input
        require(userAddress == uint256(uint160(msg.sender)), "Sender mismatch");

        // 3) Ensure the quest exists
        require(bytes(questQuestions[answerHash]).length != 0, "Quest does not exist");

        // 4) Mark current quest and all ancestors until root or already marked
        uint256 current = answerHash;
        while (current != 0 && checkIn[current][msg.sender] == 0) {
            checkIn[current][msg.sender] = block.number;
            emit CheckedIn(msg.sender, current, questQuestions[current], block.number);
            current = questDependency[current];
        }
    }

    // ------------------------------
    // Helpers
    // ------------------------------

    /**
     * @notice Returns true if the user has checked in for a given quest.
     */
    function hasCheckedIn(address user, uint256 answerHash) external view returns (bool) {
        return checkIn[answerHash][user] != 0;
    }

    /**
     * @notice Returns the block number when the user checked in for a given quest (0 if never).
     */
    function checkInBlock(address user, uint256 answerHash) external view returns (uint256) {
        return checkIn[answerHash][user];
    }

    /**
     * @notice Get total number of root quests.
     */
    function rootQuestsLength() external view returns (uint256) {
        return rootQuests.length;
    }

    /**
     * @notice Get number of children for a given dependency.
     */
    function childrenCount(uint256 dependencyHash) external view returns (uint256) {
        return questsByDependency[dependencyHash].length;
    }
}
